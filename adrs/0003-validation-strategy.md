# ADR 0003: Validation Strategy

- **Status:** Accepted
- **Date:** 2026-02-04
- **Owners:** -
- **Related:**
  - [ADR-0001: Bot Architecture](0001-bot-architecture.md)
  - [ADR-0010: Exchange Adapters](0010-exchange-adapters.md)

## Context

A trading bot operates at system boundaries where untrusted data enters the system:

1. **Environment variables** — API keys, configuration values
2. **Exchange API responses** — Prices, balances, order states, funding rates
3. **WebSocket messages** — Real-time market data
4. **Configuration files** — Trading parameters, risk limits

TypeScript's type system only provides compile-time safety. At runtime, we receive `unknown` data that must be validated before use. Without runtime validation:

- Type casts (`as`) create false safety
- Invalid data propagates silently
- Errors occur far from the source
- Debugging becomes difficult

For a trading bot, this is unacceptable. Invalid data can lead to incorrect trading decisions and financial loss.

## Decision

We will use **Valibot** for all runtime validation.

### Why Valibot Over Zod

| Criteria | Zod | Valibot |
|----------|-----|---------|
| **Bundle Size** | ~57KB (minified) | ~6KB (tree-shaken) |
| **Performance** | Good | Faster (benchmark-tested) |
| **API Style** | Method chaining | Functional composition |
| **Tree-shaking** | Partial | Full (modular design) |
| **Type Inference** | Excellent | Excellent |
| **Ecosystem** | Larger | Growing |

**Decision:** Valibot's smaller bundle size and better performance make it ideal for a long-running bot where startup time and memory matter less than Zod's larger ecosystem. The functional API also aligns with our functional programming preference (see cursor rules).

### Validation Use Cases

#### Generated vs Manual Validation

**REST API Schemas (Generated from OpenAPI):**
- For exchanges with OpenAPI specs (e.g., Coinbase Advanced Trade), schemas are **auto-generated** using `@hey-api/openapi-ts` with the Valibot plugin.
- Generated schemas live in `src/adapters/{exchange}/generated/` and are regenerated when the OpenAPI spec changes.
- **No manual schema definitions needed** for REST API responses when OpenAPI specs are available.

**Manual Schemas (Required):**
- **WebSocket messages**: Exchange-specific, not in OpenAPI specs
- **Environment variables**: Application-specific configuration
- **Trading configuration**: Domain-specific validation rules
- **Exchange adapters without OpenAPI**: Binance, Bybit (manual schemas in `src/adapters/{exchange}/schemas.ts`)

#### 1. Environment Variables

Validate all environment variables at startup. Fail fast if required values are missing.

```typescript
// src/lib/env.ts
import * as v from "valibot";

const EnvSchema = v.object({
  // Exchange credentials
  EXCHANGE_API_KEY: v.pipe(v.string(), v.minLength(1, "EXCHANGE_API_KEY is required")),
  EXCHANGE_API_SECRET: v.pipe(v.string(), v.minLength(1, "EXCHANGE_API_SECRET is required")),

  // Trading configuration
  TRADING_PAIR: v.pipe(v.string(), v.regex(/^[A-Z]+-[A-Z]+$/, "Invalid trading pair format")),
  
  // Optional with defaults
  LOG_LEVEL: v.optional(v.picklist(["debug", "info", "warn", "error"]), "info"),
  
  // Boolean from string
  DRY_RUN: v.optional(
    v.pipe(
      v.string(),
      v.transform((val) => val.toLowerCase() === "true"),
    ),
    false,
  ),
});

export type Env = v.InferOutput<typeof EnvSchema>;

export const getEnv = (): Env => v.parse(EnvSchema, process.env);
```

#### 2. Exchange API Responses

**For Coinbase (OpenAPI-generated):**
```typescript
// src/adapters/coinbase/generated/schemas.ts
// Auto-generated by @hey-api/openapi-ts with Valibot plugin
// Regenerate with: pnpm generate:sdk

import { GetFundingRateResponseSchema } from "./generated/schemas";

// Usage: Validate response using generated schema
const response = await coinbaseClient.getFundingRate({ symbol });
const validated = v.parse(GetFundingRateResponseSchema, response);
```

**For Binance/Bybit (Manual schemas):**
```typescript
// src/adapters/binance/schemas.ts
import * as v from "valibot";

// Funding rate response (manual schema)
export const FundingRateSchema = v.object({
  symbol: v.string(),
  fundingRate: v.pipe(v.string(), v.transform(Number)),
  fundingTime: v.number(),
  markPrice: v.pipe(v.string(), v.transform(Number)),
});

export type FundingRate = v.InferOutput<typeof FundingRateSchema>;

// Account balance response
export const BalanceSchema = v.object({
  asset: v.string(),
  free: v.pipe(v.string(), v.transform(BigInt)),
  locked: v.pipe(v.string(), v.transform(BigInt)),
});

export type Balance = v.InferOutput<typeof BalanceSchema>;

// Order response
export const OrderSchema = v.object({
  orderId: v.number(),
  symbol: v.string(),
  status: v.picklist(["NEW", "PARTIALLY_FILLED", "FILLED", "CANCELED", "REJECTED", "EXPIRED"]),
  side: v.picklist(["BUY", "SELL"]),
  type: v.picklist(["LIMIT", "MARKET"]),
  price: v.pipe(v.string(), v.transform(Number)),
  origQty: v.pipe(v.string(), v.transform(Number)),
  executedQty: v.pipe(v.string(), v.transform(Number)),
  time: v.number(),
});

export type Order = v.InferOutput<typeof OrderSchema>;
```

#### 3. WebSocket Messages

Validate WebSocket messages before updating state.

```typescript
// src/adapters/exchange/ws-schemas.ts
import * as v from "valibot";

// Ticker update
export const TickerMessageSchema = v.object({
  e: v.literal("24hrTicker"),
  s: v.string(), // symbol
  c: v.pipe(v.string(), v.transform(Number)), // close price
  b: v.pipe(v.string(), v.transform(Number)), // best bid
  a: v.pipe(v.string(), v.transform(Number)), // best ask
  E: v.number(), // event time
});

export type TickerMessage = v.InferOutput<typeof TickerMessageSchema>;

// Mark price update
export const MarkPriceMessageSchema = v.object({
  e: v.literal("markPriceUpdate"),
  s: v.string(),
  p: v.pipe(v.string(), v.transform(Number)), // mark price
  i: v.pipe(v.string(), v.transform(Number)), // index price
  r: v.pipe(v.string(), v.transform(Number)), // funding rate
  T: v.number(), // next funding time
});

export type MarkPriceMessage = v.InferOutput<typeof MarkPriceMessageSchema>;
```

#### 4. Configuration Validation

Validate trading configuration with domain-specific constraints.

```typescript
// src/config/schemas.ts
import * as v from "valibot";

export const TradingConfigSchema = v.object({
  // Funding rate thresholds (in basis points)
  minFundingRateBps: v.pipe(
    v.number(),
    v.minValue(1, "Minimum funding rate must be positive"),
    v.maxValue(1000, "Minimum funding rate too high"),
  ),
  
  // Position limits
  maxPositionSizeUsd: v.pipe(
    v.number(),
    v.minValue(100, "Position size must be at least $100"),
    v.maxValue(1000000, "Position size exceeds maximum"),
  ),
  
  // Risk parameters
  maxLeverageBps: v.pipe(
    v.number(),
    v.minValue(10000, "Leverage must be at least 1x"),
    v.maxValue(100000, "Leverage exceeds 10x maximum"),
  ),
  
  // Slippage tolerance (in basis points)
  maxSlippageBps: v.pipe(
    v.number(),
    v.minValue(1),
    v.maxValue(500, "Slippage tolerance too high"),
  ),
});

export type TradingConfig = v.InferOutput<typeof TradingConfigSchema>;
```

### Validation Patterns

#### Pattern 1: Parse at System Boundaries

Validate data immediately when it enters the system. After validation, trust the types.

```typescript
// ✅ Good: Validate at boundary using generated schema (Coinbase)
const fetchFundingRate = async (symbol: string): Promise<FundingRate> => {
  const response = await coinbaseClient.getFundingRate({ symbol });
  // Use generated schema from OpenAPI spec
  return v.parse(GetFundingRateResponseSchema, response);
};

// ✅ Good: Validate at boundary using manual schema (Binance)
const fetchFundingRateBinance = async (symbol: string): Promise<FundingRate> => {
  const response = await binanceClient.get(`/funding/${symbol}`);
  return v.parse(FundingRateSchema, response.data); // Manual schema
};

// Internal code can trust the type (same for both)
const evaluate = (rate: FundingRate): Decision => {
  if (rate.fundingRate > threshold) { // No validation needed
    return { action: "ENTER" };
  }
  return { action: "WAIT" };
};
```

#### Pattern 2: Safe Parse for Recoverable Errors

Use `safeParse` when validation failure is expected and recoverable.

```typescript
// ✅ Good: Safe parse for WebSocket messages (may receive unknown event types)
const handleMessage = (data: unknown): void => {
  const tickerResult = v.safeParse(TickerMessageSchema, data);
  if (tickerResult.success) {
    updateTicker(tickerResult.output);
    return;
  }
  
  const markPriceResult = v.safeParse(MarkPriceMessageSchema, data);
  if (markPriceResult.success) {
    updateMarkPrice(markPriceResult.output);
    return;
  }
  
  // Unknown message type - log and ignore
  logger.debug("Unknown WebSocket message", { data });
};
```

#### Pattern 3: Type Guards with `is()`

Use `v.is()` for type guards without throwing.

```typescript
// ✅ Good: Type guard for conditional logic
const isValidOrder = (data: unknown): data is Order =>
  v.is(OrderSchema, data);

// Usage
if (isValidOrder(response)) {
  processOrder(response); // Type narrowed to Order
} else {
  logger.warn("Invalid order response", { response });
}
```

#### Pattern 4: Transform During Validation

Use `transform` to convert data types during validation.

```typescript
// ✅ Good: Transform strings to appropriate types
const PriceSchema = v.pipe(
  v.string(),
  v.transform((val) => {
    const num = Number(val);
    if (Number.isNaN(num)) throw new Error("Invalid number");
    return num;
  }),
);

// ✅ Good: Transform to bigint for financial values
const AmountSchema = v.pipe(
  v.string(),
  v.transform((val) => BigInt(val)),
);
```

#### Pattern 5: Custom Validation Messages

Always provide clear error messages.

```typescript
// ✅ Good: Descriptive error messages
const ApiKeySchema = v.pipe(
  v.string(),
  v.minLength(32, "API key must be at least 32 characters"),
  v.regex(/^[a-zA-Z0-9]+$/, "API key must be alphanumeric"),
);
```

### File Organization

```
src/
├── lib/
│   └── env.ts                    # Environment validation (manual)
├── config/
│   └── schemas.ts                # Trading configuration schemas (manual)
├── adapters/
│   ├── coinbase/
│   │   ├── generated/            # Auto-generated from OpenAPI spec
│   │   │   └── schemas.ts        # Generated Valibot schemas
│   │   └── ws-schemas.ts         # WebSocket message schemas (manual)
│   ├── binance/
│   │   ├── schemas.ts            # REST API response schemas (manual)
│   │   └── ws-schemas.ts         # WebSocket message schemas (manual)
│   └── bybit/
│       ├── schemas.ts            # REST API response schemas (manual)
│       └── ws-schemas.ts         # WebSocket message schemas (manual)
└── domains/
    └── order/
        └── schemas.ts            # Domain-specific schemas (manual)
```

### Conventions

1. **Schema suffix**: All schema variables end with `Schema` (e.g., `OrderSchema`)
2. **Co-locate types**: Export inferred types alongside schemas
3. **Namespace import**: Always import as `import * as v from "valibot"`
4. **Fail fast**: Use `parse` at startup, `safeParse` for runtime messages
5. **Transform early**: Convert strings to numbers/bigints during validation
6. **Generated schemas**: Never edit generated schema files; regenerate from OpenAPI spec
7. **Manual schemas**: Keep manual schemas in `schemas.ts` files, separate from generated code

## Consequences

### Positive

- **Runtime Safety**: Invalid data caught at system boundaries
- **Type Inference**: No manual type definitions needed (`InferOutput`)
- **Small Bundle**: Valibot's modular design keeps bundle size minimal
- **Clear Errors**: Validation errors pinpoint exactly what's wrong
- **Testable**: Schemas can be unit tested independently

### Negative

- **Learning Curve**: Team must learn Valibot's functional API
- **Smaller Ecosystem**: Fewer integrations than Zod (rarely an issue for this use case)
- **Verbosity**: Schema definitions add code (but provide safety)

### Risks

| Risk | Mitigation |
|------|------------|
| Schema drift from API | Regular testing against live API responses; regenerate OpenAPI schemas when spec changes |
| Over-validation | Only validate at boundaries, trust internal data |
| Performance overhead | Validation is fast; measure if concerned |
| Generated schema out of sync | Run `pnpm generate:sdk` after OpenAPI spec updates; add CI check |
| Manual schema maintenance | Document manual schemas; consider migrating to OpenAPI when available |

## References

- [Valibot Documentation](https://valibot.dev/)
- [Valibot vs Zod Comparison](https://valibot.dev/guides/introduction/#comparison-to-other-libraries)
- [TypeScript Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
